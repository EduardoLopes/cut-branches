
// This file was generated by [tauri-specta](https://github.com/oscartbeaumont/tauri-specta). Do not edit this file manually.

/** user-defined commands **/


export const commands = {
/**
 * Gets the root path of a git repository.
 * 
 * # Arguments
 * 
 * * `input` - Input parameters containing the path to check
 * 
 * # Returns
 * 
 * * `Result<GetRepositoryRootOutput, AppError>` - The root path and ID, or an error
 */
async getRepositoryRoot(input: GetRepositoryRootInput) : Promise<Result<GetRepositoryRootOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_repository_root", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Gets information about a git repository.
 * 
 * # Arguments
 * 
 * * `input` - Input parameters containing the repository path
 * 
 * # Returns
 * 
 * * `Result<GetRepositoryOutput, AppError>` - Repository information or an error
 */
async getRepository(input: GetRepositoryInput) : Promise<Result<GetRepositoryOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("get_repository", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Switches to another branch in a git repository.
 * 
 * # Arguments
 * 
 * * `input` - Input parameters containing path and branch name
 * 
 * # Returns
 * 
 * * `Result<SwitchBranchOutput, AppError>` - The new current branch name or an error
 */
async switchBranch(input: SwitchBranchInput) : Promise<Result<SwitchBranchOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("switch_branch", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Deletes branches from a git repository.
 * 
 * # Arguments
 * 
 * * `input` - Input parameters containing path and branch names to delete
 * 
 * # Returns
 * 
 * * `Result<DeleteBranchesOutput, AppError>` - The deleted branches or an error
 */
async deleteBranches(input: DeleteBranchesInput) : Promise<Result<DeleteBranchesOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("delete_branches", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Checks if a commit SHA is reachable in a git repository.
 * 
 * # Arguments
 * 
 * * `input` - Input parameters containing path and commit SHA
 * 
 * # Returns
 * 
 * * `Result<IsCommitReachableOutput, AppError>` - The reachability status or an error
 */
async isCommitReachable(input: IsCommitReachableInput) : Promise<Result<IsCommitReachableOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("is_commit_reachable", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Restores a deleted branch in a git repository.
 * 
 * # Arguments
 * 
 * * `app` - The AppHandle
 * * `input` - Input parameters containing path and branch info
 * 
 * # Returns
 * 
 * * `Result<RestoreBranchOutput, AppError>` - The restoration result or an error
 */
async restoreBranch(input: RestoreBranchInput) : Promise<Result<RestoreBranchOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_branch", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
},
/**
 * Restores multiple deleted branches in a git repository.
 * 
 * # Arguments
 * 
 * * `app` - The AppHandle
 * * `input` - Input parameters containing path and branch infos
 * 
 * # Returns
 * 
 * * `Result<RestoreBranchesOutput, AppError>` - The restoration results or an error
 */
async restoreBranches(input: RestoreBranchesInput) : Promise<Result<RestoreBranchesOutput, AppError>> {
    try {
    return { status: "ok", data: await TAURI_INVOKE("restore_branches", { input }) };
} catch (e) {
    if(e instanceof Error) throw e;
    else return { status: "error", error: e  as any };
}
}
}

/** user-defined events **/


export const events = __makeEvents__<{
branchDeleted: BranchDeletedEvent,
branchRestored: BranchRestoredEvent,
branchSwitched: BranchSwitchedEvent,
notification: NotificationEvent,
repositoryLoaded: RepositoryLoadedEvent
}>({
branchDeleted: "branch-deleted",
branchRestored: "branch-restored",
branchSwitched: "branch-switched",
notification: "notification",
repositoryLoaded: "repository-loaded"
})

/** user-defined constants **/



/** user-defined types **/

export type AppError = { message: string; kind: string; description: string | null }
export type Branch = { name: string; fullyMerged: boolean; lastCommit: Commit; current: boolean }
export type BranchDeletedEvent = { deletedBranches: DeletedBranchInfo[]; repositoryPath: string }
export type BranchRestoredEvent = { restoredBranch: Branch; repositoryPath: string }
export type BranchSwitchedEvent = { fromBranch: string; toBranch: string; repositoryPath: string }
export type Commit = { sha: string; shortSha: string; date: string; message: string; author: string; email: string }
export type ConflictDetails = { originalName: string; conflictingName: string }
export type ConflictResolution = "Overwrite" | "Rename" | "Skip"
export type DeleteBranchesInput = { path: string; branches: string[] }
export type DeleteBranchesOutput = { deletedBranches: DeletedBranchInfo[] }
export type DeletedBranch = { originalName: string; targetName: string; commitSha: string; conflictResolution: ConflictResolution | null }
export type DeletedBranchInfo = { branch: Branch; rawOutput: string }
export type GetRepositoryInput = { path: string }
export type GetRepositoryOutput = { path: string; branches: Branch[]; currentBranch: string; branchesCount: number; name: string; id: string }
export type GetRepositoryRootInput = { path: string }
export type GetRepositoryRootOutput = { rootPath: string; id: string | null }
export type IsCommitReachableInput = { path: string; commitSha: string }
export type IsCommitReachableOutput = { isReachable: boolean }
export type NotificationEvent = { title: string; message: string; kind: NotificationKind; duration: number | null }
export type NotificationKind = "Success" | "Error" | "Warning" | "Info"
export type RepositoryLoadedEvent = { repositoryPath: string; repositoryName: string; branchesCount: number }
export type RestoreBranchInput = { path: string; branchInfo: DeletedBranch }
export type RestoreBranchOutput = { result: RestoreBranchResult }
export type RestoreBranchResult = { success: boolean; branchName: string; message: string; requiresUserAction: boolean; conflictDetails: ConflictDetails | null; skipped: boolean; branch: Branch | null }
export type RestoreBranchesInput = { path: string; branchInfos: DeletedBranch[] }
export type RestoreBranchesOutput = { results: RestoreBranchResult[] }
export type SwitchBranchInput = { path: string; branch: string }
export type SwitchBranchOutput = { currentBranch: string }

/** tauri-specta globals **/

import {
	invoke as TAURI_INVOKE,
	Channel as TAURI_CHANNEL,
} from "@tauri-apps/api/core";
import * as TAURI_API_EVENT from "@tauri-apps/api/event";
import { type WebviewWindow as __WebviewWindow__ } from "@tauri-apps/api/webviewWindow";

type __EventObj__<T> = {
	listen: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.listen<T>>;
	once: (
		cb: TAURI_API_EVENT.EventCallback<T>,
	) => ReturnType<typeof TAURI_API_EVENT.once<T>>;
	emit: null extends T
		? (payload?: T) => ReturnType<typeof TAURI_API_EVENT.emit>
		: (payload: T) => ReturnType<typeof TAURI_API_EVENT.emit>;
};

export type Result<T, E> =
	| { status: "ok"; data: T }
	| { status: "error"; error: E };

function __makeEvents__<T extends Record<string, any>>(
	mappings: Record<keyof T, string>,
) {
	return new Proxy(
		{} as unknown as {
			[K in keyof T]: __EventObj__<T[K]> & {
				(handle: __WebviewWindow__): __EventObj__<T[K]>;
			};
		},
		{
			get: (_, event) => {
				const name = mappings[event as keyof T];

				return new Proxy((() => {}) as any, {
					apply: (_, __, [window]: [__WebviewWindow__]) => ({
						listen: (arg: any) => window.listen(name, arg),
						once: (arg: any) => window.once(name, arg),
						emit: (arg: any) => window.emit(name, arg),
					}),
					get: (_, command: keyof __EventObj__<any>) => {
						switch (command) {
							case "listen":
								return (arg: any) => TAURI_API_EVENT.listen(name, arg);
							case "once":
								return (arg: any) => TAURI_API_EVENT.once(name, arg);
							case "emit":
								return (arg: any) => TAURI_API_EVENT.emit(name, arg);
						}
					},
				});
			},
		},
	);
}
